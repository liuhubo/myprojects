package com.hello.binary.tree;
public class HashLearn {

	/**
	 * HashMap->Hash算法与Hash冲突参考下面:
	 * http://blog.csdn.net/ghsau/article/details/16890151 当容量一定是2^n时，
	 * h & (length - 1) == h %length，它俩是等价不等效的，位运算效率非常高，实际开发中，很多的数值运算以及逻辑判断都可以转换成位运算
	 * ，但是位运算通常是难以理解的，因为其本身就是给电脑运算的
	 * ，运算的是二进制，而不是给人类运算的，人类运算的是十进制，这也是位运算在普遍的开发者中间不太流行的原因
	 * (门槛太高)。这个等式实际上可以推理出来，2^n转换成二进制就是1+n个0，减1之后就是0+n个1，如16 -> 10000，15 ->
	 * 01111，那根据&位运算的规则，都为1(真)时，才为1，那0≤运算后的结果≤15，假设h <= 15，那么运算后的结果就是h本身，h
	 * >15，运算后的结果就是最后三位二进制做
	 * &运算后的值，最终，就是%运算后的余数，我想，这就是容量必须为2的幂的原因。HashTable中的实现对容量的大小没有规定
	 * ，最终的bucketIndex是通过取余来运算的
	 * 。注：我在考虑这样做是否真的是最好，规定容量大小一定为2的幂会浪费许多空间成本，而时间上的优化针对当今越来越牛逼的CPU是否还提升了许多
	 * ，有些资料上说
	 * ，CPU处理除法和取余运算是最慢的，这个应该取决于语言调用CPU指令的顺序和CPU底层实现的架构，也是有待验证，可以用Java写段程序测试一下
	 * ，不过我想，CPU也是通过人来实现，人脑运算的速度应该是加法>减法>乘法>除法>取模(这里指的是正常的算法，不包括速算)，CPU也应是如此。
	 * 
	 * 
	 * 
	 * 
	 * 
	 */

}
